@name lib/camolib2
@persist [Base]:entity
@persist [ColorLookup Database Types]:table
@persist [DefaultCamo Camo CamoKey]:string
@persist [Keys Entities PropStorage]:array
@persist [Count NoName MatMode Reset]:number
@persist [AutoPaint Wait Amount]:number

#----------------------------------- Library made by TwistedTail - Version 2.1 -----------------------------------#
#------------------------------------------ Updates for this library: --------------------------------------------#
#--------------------- https://github.com/TwistedTail/Public-E2s/tree/master/Camo%20E2%20V2 ----------------------#
#--------- Remember to create a folder called "lib" inside your Expression2 folder before saving this E2 ---------#
#---------- This E2 doesn't has to be spawned into your contraption. I also suggest you to not edit it -----------#

ColorLookup = table("[255,0,0]" = "R", "[0,255,0]" = "G", "[0,0,255]" = "B", "[0,255,255]" = "C", "[255,255,0]" = "Y", "[255,0,255]" = "M")
Keys = array("R","G","B","C","Y","M")

timer("Spawning", 100)

#Every message that could be displayed by the E2 will be stored here
function showMessage(Message:string)
{
    switch (Message)
    {
        case "OutdatedWire",
            printColor(vec(200,0,0),"[Camo] ", vec(255), "You're using an outdated version of Wiremod!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Findind all your spawned entities instead.")
        break
        case "NoEntsFound",
            printColor(vec(200,0,0),"[Camo] ", vec(255), "No entities were found.")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Make sure to wire Base and type !cr to restart the E2.")
        break
        case "ForcedReset",
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Forced reset detected!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Remember to use !cr to restart the E2 properly.")
        break
        case "CamoNotFound",
            if (!Camo) { break }

            printColor(vec(200,0,0),"[Camo] ", vec(255), "Camouflage "+Camo+" not found!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Write !cl to list all the available camouflages.")
        break
        case "MapNotFound",
            if (!AutoPaint) { break }

            printColor(vec(200,0,0),"[Camo] ", vec(255), "Map "+map()+" not found, using the default camouflage!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Write !cl to list all the available camouflages.")
        break
        case "ListCamo",
            local Msg   = array(vec(200,0,0),"[Camo] ", vec(120,255,120), "Available camouflages:\n", vec(255))
            local Text  = ""
            local Count = Database:count()

            foreach (I, K:string = Database:keys()){ 
                Text += K
                if (I != Count){ Text += ", " }
            }
            Msg:pushString(Text)

            printColor(Msg)
        break
    }
}

#Function to get the name of the camo that has the current map on its map list
#If the map doesn't exists on any camo then it'll show an error message and pick the default one
function string getMapCamo()
{
    local Map = map()

    foreach (K:string, V:table = Database)
    {
        local Maps = V["Maps", table]
        
        if (Maps[Map, number]){ return K }
    }

    showMessage("MapNotFound")
    return DefaultCamo
}

#Extremely ghetto function, used to detect when the contraption stops spawning holograms so we can get all of them
function waitForSpawn()
{
    local Timer = "Spawning"

    if (Amount == holoAmount())
    {
        Wait++
        if (Wait >= 21) { Timer = "GetContraption" }
    }
    else
    {
        Wait = 0
    }

    Amount = holoAmount()

    timer(Timer, 100)
}

#Called when we need to get the entire contraption
#If the required function doesn't exists then we just get all your stuff
function getContraption()
{
    local Timer = "SortEntities"

    #ifdef entity:getConnectedEntities(...)
        Entities = Base:getConnectedEntities("All", "-Wires")
    #else
        showMessage("OutdatedWire")

        findIncludePlayerProps(owner())
        findExcludeEntity(owner())
        findByClass("*")

        Entities = findToArray()
    #endif

    if (Entities:count() <= 1)
    {
        showMessage("NoEntsFound")

        Timer = "LastAction"
    }

    timer(Timer, 200)
}

#Function to sort the entities by their color
function sortEntities()
{
    local Timer = "SortEntities"
    local EntCount = Entities:count()

    while (perf() & Count <= EntCount)
    {
        Count++
        local Entity = Entities[Count, entity]
        local Color = Entity:getColor():toString()
        local HasColor = ColorLookup[Color, string]
        
        if (HasColor)
        {
            Entity["C", string] = HasColor
            Entity["Mat", string] = Entity:getMaterial()
            PropStorage:pushEntity(Entity)
        }
    }

    if (Count >= EntCount)
    {
        if (AutoPaint) { Camo = getMapCamo() }

        Count = 0

        Timer = "ApplyColors"
    }

    timer(Timer, 200)
}

#Function to change the color of the entities
function applyColors()
{
    local DB = Database[Camo, table]
    local PropCount = PropStorage:count()
    local Timer = "ApplyColors"
    
    if (!DB)
    {
        showMessage("CamoNotFound")
        Timer = "LastAction"
    }
    else
    {
        Types = DB:typeids()
        
        while (perf() & Count <= PropCount)
        {
            Count++
            local Entity = PropStorage[Count, entity]
            local ColorID = Entity["C", string]
            
            if (Types[ColorID, string] == "v") {
                local Color = DB[ColorID, vector]
                
                Entity:setColor(Color)
            }
        }
        if (Count >= PropCount) { Count = 0 Timer = "ApplyMaterials" }
    }

    timer(Timer, 200)
}

#Function to change the material of the entities
function setMaterial(N:number, DB:table)
{
    local Timer = "ApplyMaterials"
    local PropCount = PropStorage:count()

    while (perf() & Count <= PropCount)
    {
        Count++
        local Entity = PropStorage[Count, entity]
        local MatID = "Mat" + Entity["C", string]

        if (Types[MatID, string] == "s")
        {
            local Material = DB[MatID, string]

            Entity:setMaterial(Material)
        }
    }
    if (Count >= PropCount) { MatMode = N Count = 0 Timer = "LastAction" }

    timer(Timer, 200)
}

#Function to return the material of the entities to what it had when it was first detected
function resetMaterial(N:number)
{
    local PropCount = PropStorage:count()

    while (perf() & Count <= PropCount)
    {
        Count++
        local Entity = PropStorage[Count, entity]
        local Material = Entity["Mat", string]
    
        Entity:setMaterial(Material)
    }
    if (Count >= PropCount) { MatMode = N Count = 0 Timer = "LastAction" }
    
    timer(Timer, 200)
}

#Function that will decide if the material will be changed, resetted or kept the same
function applyMaterials()
{
    local DB = Database[Camo, table]
    local HasMat = DB["Mat", number]

    switch (MatMode - HasMat)
    {
        case 1, resetMaterial(HasMat) break
        case -1, setMaterial(HasMat, DB) break
        case 0,
            if (MatMode)
            {
                setMaterial(HasMat, DB)
            }
            else
            {
                MatMode = HasMat

                timer("LastAction", 200)
            }
        break
    }
}

#Function called whenever a timer triggers the E2
function timerAction()
{
    switch (clkName())
    {
        case "Spawning", waitForSpawn() break
        case "GetContraption", getContraption() break
        case "SortEntities", sortEntities() break
        case "ApplyColors", applyColors() break
        case "ApplyMaterials", applyMaterials() break
        case "LastAction",
            runOnChat(1)
            runOnLast(1)

            if (Reset) { reset() }
        break
    }
}

#Function to do the actions called by the different available chat commands
function chatCommand()
{
    local Said = lastSaid():lower():explode(" ")

    switch (Said[1, string])
    {
        case "!camo-list",  case "!camolist", case "!clist", case "!cl",
            hideChat(1)

            showMessage("ListCamo")
        break
        case "!camo-reset",  case "!camoreset", case "!creset", case "!cr",
            hideChat(1)
            runOnChat(0)

            Camo = "undo"
            Reset = 1

            applyColors()
        break
        case "!camo", case "!c",
            hideChat(1)
            runOnChat(0)

            Camo = Said[2, string] 

            applyColors()
        break
    }    
}

#Function to generate a super basic set of colors based on a given vector color
function array basicCamo(Red:vector)
{
    local Green = round(Red * vec(1.18))
    local Blue = round(Red * vec(0.82))
    local Cyan = round(Red * vec(1.05,1.01,1.1))
    local Yellow = round(Cyan * vec(1.22))
    local Magenta = round(Cyan * vec(0.9))

    return array(Red, Green, Blue, Cyan, Yellow, Magenta)
}

#Function to add maps to set the camo automatically
function maps(Maps:array) { Database[CamoKey, table]["Maps", table] = invert(Maps) }

#Function to set all the colors of the camouflage to the same
function colors(Color:vector)
{
    foreach (K, Key:string = Keys)
    {
        Database[CamoKey, table][Key, vector] = Color
    }
}

#Function to set a specific color on the current camouflage
function colors(Key:string, Color:vector)
{
    if (!invert(Keys)[Key, number]){ return }

    Database[CamoKey, table][Key, vector] = Color
}

#Function to define the colors of the last added camo with an array
function colors(Colors:array)
{
    local Count = min(Colors:count(), 6)

    if (!Count) { return }

    for (I = 1, Count){
        local Key = Keys[I, string]
        local Color = Colors[I, vector]

        Database[CamoKey, table][Key, vector] = Color
    }
}

#Function to define a new material for all the painted props on the last added camo
function material(Material:string)
{
    Database[CamoKey, table]["Mat", number] = 1

    foreach (K, Key:string = Keys)
    {
        Database[CamoKey, table]["Mat" + Key, string] = Material
    }
}

#Function to set a specific material on the current camouflage
function material(Key:string, Material:string)
{
    if (!invert(Keys)[Key, number]){ return }

    Database[CamoKey, table]["Mat", number] = 1
    Database[CamoKey, table]["Mat" + Key, string] = Material
}

#Non family friendly function to define a new material for all the painted props on the last added camo
function material(Materials:array)
{
    local Count = min(Materials:count(), 6)

    if (!Count) { return }

    Database[CamoKey, table]["Mat", number] = 1

    for (I = 1, Count){
        local Key = "Mat" + Keys[I, string]
        local Material = Materials[I, string]

        Database[CamoKey, table][Key, string] = Material
    }
}

#Function to add a new camouflage to the database
function addCamo(S:string)
{
    CamoKey = S:replace(" ","")

    if (!CamoKey | CamoKey == "undo") { NoName++ CamoKey = "camo"+NoName }

    Database[CamoKey, table] = table()

    foreach (K, V:string = Keys)
    {
        Database[CamoKey, table][V, vector] = vec(255)
    }
}

CamoKey = "undo" Database[CamoKey, table] = table()
    colors(array(vec(255,0,0), vec(0,255,0), vec(0,0,255), vec(0,255,255), vec(255,255,0), vec(255,0,255)))

addCamo("clean")
    material("")
