@name lib/camolib
@persist [Base]:entity
@persist [LT Database]:table
@persist [DefaultCamo Camo CamoKey]:string
@persist [Keys Entities PropStorage]:array
@persist [Count NoName MatMode Reset]:number
@persist [AutoPaint Wait Amount]:number

#----------------------------------- Library made by TwistedTail - Version 2.0 -----------------------------------#
#------------------------------------------ Updates for this library: --------------------------------------------#
#--------------------- https://github.com/TwistedTail/Public-E2s/tree/master/Camo%20E2%20V2 ----------------------#
#--------- Remember to create a folder called "lib" inside your Expression2 folder before saving this E2 ---------#
#---------- This E2 doesn't has to be spawned into your contraption. I also suggest you to not edit it -----------#

LT = table("[255,0,0]" = "R", "[0,255,0]" = "G", "[0,0,255]" = "B", "[0,255,255]" = "C", "[255,255,0]" = "Y", "[255,0,255]" = "M")
Keys = array("R","G","B","C","Y","M")

timer("Spawning", 100)

#Every message that could be displayed by the E2 will be stored here
function showMessage(Message:string)
{
    switch (Message)
    {
        case "OutdatedWire",
            printColor(vec(200,0,0),"[Camo] ", vec(255), "You're using an outdated version of Wiremod!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Findind all your spawned entities instead!")
        break
        case "ForcedReset",
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Forced reset detected!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Remember to use !cr to restart the E2 properly.")
        break
        case "CamoNotFound",
            if (!Camo) { break }
            
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Camouflage "+Camo+" not found!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Write !cl to list all the available camouflages.")
        break
        case "MapNotFound",
            if (!AutoPaint) { break }
            
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Map "+map()+" not found, using the default camouflage!")
            printColor(vec(200,0,0),"[Camo] ", vec(255), "Write !cl to list all the available camouflages.")
        break
        case "ListCamo",
            local Msg   = array(vec(200,0,0),"[Camo] ", vec(120,255,120), "Available camouflages:\n", vec(255))
            local Text  = ""
            local Count = Database:count()
                    
            foreach (I, K:string = Database:keys()){ 
                Text += K
                if (I != Count){ Text += ", " }
            }
            Msg:pushString(Text)
                    
            printColor(Msg)
        break
    }
}

#Function to get the name of the camo that has the current map on its map list
#If the map doesn't exists on any camo then it'll show an error message and pick the default one
function string getMapCamo()
{
    local Map = map()
    
    foreach (I, C:table = Database)
    {
        local M = C["Maps", table]
        
        if (M[Map,number]){ return I }
    }
    
    showMessage("MapNotFound")
    return DefaultCamo
}

#Extremely ghetto function, used to detect when the contraption stops spawning holograms so we can get all of them
function waitForSpawn()
{
    local Timer = "Spawning"
    
    if (Amount == holoAmount())
    {
        Wait++
        if (Wait >= 11) { Timer = "GetContraption" }
    }
    else
    {
        Wait = 0
    }
    
    Amount = holoAmount()
    
    timer(Timer, 100)
}

function getContraption()
{
    #ifdef entity:getConnectedEntities(...)
        Entities = Base:getConnectedEntities("All", "-Wires")
    #else
        showMessage("OutdatedWire")
    
        findIncludePlayerProps(owner())
        findExcludeEntity(owner())
        findByClass("*")

        Entities = findToArray()
    #endif
    
    timer("SortEntities", 200)
}

#Function to sort the props by their color
function sortEntities()
{
    local Timer = "SortEntities"
    local EntCount = Entities:count()
    
    while (perf() & Count <= EntCount)
    {
        Count++
        local E = Entities[Count, entity]
        local C = E:getColor():toString()
        local M = E:getMaterial()
        local S = LT[C, string]
        
        if (S) { E["C", string] = S E["Mat", string] = M PropStorage:pushEntity(E) }
    }
    
    if (Count >= EntCount)
    {
        if (AutoPaint) { Camo = getMapCamo() }
        
        Count = 0
        
        Timer = "ApplyColors"
    }
    
    timer(Timer, 200)
}

#Function to change the color of the entities
function applyColors()
{
    local DB = Database[Camo, table]
    local PropCount = PropStorage:count()
    local Timer = "ApplyColors"
    
    if (!DB) { showMessage("CamoNotFound") return }
    
    while (perf() & Count <= PropCount)
    {
        Count++
        local E = PropStorage[Count, entity]
        local C = E["C", string]
        local V = DB[C, vector]
        
        if (V) { E:setColor(V) }
    }
    if (Count >= PropCount) { Count = 0 Timer = "ApplyMaterials" }
    
    timer(Timer, 200)
}

#Function to change the material of the entities
function setMaterial(N:number, DB:table)
{
    local Timer = "ApplyMaterials"
    local PropCount = PropStorage:count()
    
    while (perf() & Count <= PropCount)
    {
        Count++
        local E = PropStorage[Count, entity]
        local C = E["C", string]
        local M = DB["Mat"+C, string]
        
        if (M != "na") { E:setMaterial(M) }
    }
    if (Count >= PropCount) { MatMode = N Count = 0 Timer = "LastAction" }
    
    timer(Timer, 200)
}

#Function to return the material of the entities to what it had when it was first detected
function resetMaterial(N:number)
{
    local PropCount = PropStorage:count()
    
    while (perf() & Count <= PropCount)
    {
        Count++
        local E = PropStorage[Count, entity]
        local M = E["Mat", string]
        
        E:setMaterial(M)
    }
    if (Count >= PropCount) { print("resetMaterial end") MatMode = N Count = 0 Timer = "LastAction" }
    
    timer(Timer, 200)
}

#Function that will decide if the material will be changed, resetted or kept the same
function applyMaterials()
{
    local DB = Database[Camo, table]
    local MM = DB["Mat", number]
    
    print("applyMaterial", MatMode - MM)
    
    switch (MatMode - MM)
    {
        case 1, resetMaterial(MM) break
        case -1, setMaterial(MM, DB) break
        case 0, if (MatMode) { setMaterial(MM, DB) } else { MatMode = MM timer("LastAction", 200) } break
    }
}

function timerAction()
{
    switch (clkName())
    {
        case "Spawning", waitForSpawn() break
        case "GetContraption", getContraption() break
        case "SortEntities", sortEntities() break
        case "ApplyColors", applyColors() break
        case "ApplyMaterials", applyMaterials() break
        case "LastAction",
            runOnChat(1)
            runOnLast(1)

            if (Reset) { reset() }
        break
    }
}

#Function to do the actions called by the different available chat commands
function chatCommand()
{
    local Said = lastSaid():lower():explode(" ")
    
    switch (Said[1, string])
    {
        case "!cl", hideChat(1) showMessage("ListCamo") break
        case "!cr",
            hideChat(1)
            runOnChat(0)
            
            Camo = "undo"
            Reset = 1
            
            applyColors()
        break
        case "!c",
            hideChat(1)
            runOnChat(0)
            
            Camo = Said[2, string] 
            
            applyColors()
        break
    }    
}

#Function to generate a super basic set of colors based on a given vector color
function array basicCamo(R:vector)
{
    local G = round(R * vec(1.18))
    local B = round(R * vec(0.82))
    local C = round(R * vec(1.05,1.01,1.1))
    local Y = round(C * vec(1.22))
    local M = round(C * vec(0.9))
        
    return array(R, G, B, C, Y, M)
}

#Function to add maps to set the camo automatically
function maps(A:array) { Database[CamoKey, table]["Maps", table] = invert(A) }

#Function to set all the colors of the camouflage to the same
function colors(V:vector)
{
    if (!V){ return }
    
    Database[CamoKey, table]["R", vector] = V
    Database[CamoKey, table]["G", vector] = V
    Database[CamoKey, table]["B", vector] = V
    Database[CamoKey, table]["C", vector] = V
    Database[CamoKey, table]["Y", vector] = V
    Database[CamoKey, table]["M", vector] = V
}

function colors(C:string, V:vector)
{
    if (!invert(Keys)[C, number]){ return }
    if (!V){ return }
    
    Database[CamoKey, table][C, vector] = V
}

#Function to define the colors of the last added camo with an array
function colors(A:array)
{
    local C = min(A:count(), 6)
    
    if (!C){ return }
    
    for (I = 1, C){
        local M = Keys[I, string]
        local V = A[I, vector]
        
        if (!V){ continue }
        
        Database[CamoKey, table][M, vector] = V
    }
}

#Function to define a new material for all the painted props on the last added camo
function material(M:string)
{
    Database[CamoKey, table]["Mat", number]  = 1
    Database[CamoKey, table]["MatR", string] = M
    Database[CamoKey, table]["MatG", string] = M
    Database[CamoKey, table]["MatB", string] = M
    Database[CamoKey, table]["MatC", string] = M
    Database[CamoKey, table]["MatY", string] = M
    Database[CamoKey, table]["MatM", string] = M
}

function material(C:string, M:string)
{
    if (!invert(Keys)[C, number]){ return }
    
    Database[CamoKey, table]["Mat", number]   = 1
    Database[CamoKey, table]["Mat"+C, string] = M
}

#Non family friendly function to define a new material for all the painted props on the last added camo
function material(A:array)
{
    local C = min(A:count(), 6)
    
    if (!C){ return }
    
    Database[CamoKey, table]["Mat", number] = 1
    
    for (I = 1, C){
        local M = Keys[I, string]
        local V = A[I, string]
        
        Database[CamoKey, table]["Mat"+M, string] = V
    }
}

#Function to add a new camouflage to the database
function addCamo(S:string) {
    CamoKey = S:replace(" ","")
    
    if (!CamoKey | CamoKey == "undo") { NoName++ CamoKey = "camo"+NoName }
    
    Database[CamoKey, table] = table()
        material("na")
        Database[CamoKey, table]["Mat", number] = 0
}

CamoKey = "undo" Database[CamoKey, table] = table()
    colors(array(vec(255,0,0), vec(0,255,0), vec(0,0,255), vec(0,255,255), vec(255,255,0), vec(255,0,255)))
    
addCamo("clean")
    colors(vec(255))
    material("")
